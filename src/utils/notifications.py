"""
Notification management system for automation agents.

Supports multiple notification channels:
- Email notifications
- Slack integration
- SMS alerts (via Twilio)
- Webhook notifications
- In-app notifications
"""

import logging
import smtplib
import json
import requests
from datetime import datetime
from typing import Dict, List, Optional, Any
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from dataclasses import dataclass

logger = logging.getLogger(__name__)

@dataclass
class NotificationConfig:
    """Configuration for notification channels"""
    email_enabled: bool = True
    slack_enabled: bool = False
    sms_enabled: bool = False
    webhook_enabled: bool = False

    # Email settings
    smtp_host: str = "smtp.gmail.com"
    smtp_port: int = 587
    smtp_username: str = ""
    smtp_password: str = ""
    from_email: str = ""

    # Slack settings
    slack_webhook_url: str = ""
    slack_channel: str = "#automation"

    # SMS settings (Twilio)
    twilio_account_sid: str = ""
    twilio_auth_token: str = ""
    twilio_from_number: str = ""

    # Webhook settings
    webhook_urls: List[str] = None

    # Default recipients
    default_email_recipients: List[str] = None
    default_sms_recipients: List[str] = None

class NotificationManager:
    """
    Centralized notification management for automation agents.
    Handles multiple notification channels with priority routing.
    """

    def __init__(self, config: Dict):
        self.config = NotificationConfig(**config)

        # Priority mapping
        self.priority_channels = {
            'critical': ['email', 'sms', 'slack'],
            'high': ['email', 'slack'],
            'medium': ['email'],
            'low': ['slack']
        }

    def send_notification(self, title: str, message: str,
                         priority: str = 'medium',
                         recipients: Optional[List[str]] = None,
                         channels: Optional[List[str]] = None) -> Dict[str, bool]:
        """
        Send notification through appropriate channels based on priority.

        Args:
            title: Notification title
            message: Notification message
            priority: Priority level (critical, high, medium, low)
            recipients: Optional specific recipients
            channels: Optional specific channels to use

        Returns:
            Dictionary with success status for each channel
        """
        results = {}

        # Determine channels to use
        if channels is None:
            channels = self.priority_channels.get(priority, ['email'])

        # Send through each channel
        for channel in channels:
            try:
                if channel == 'email' and self.config.email_enabled:
                    results['email'] = self._send_email(title, message, recipients)
                elif channel == 'slack' and self.config.slack_enabled:
                    results['slack'] = self._send_slack(title, message)
                elif channel == 'sms' and self.config.sms_enabled:
                    results['sms'] = self._send_sms(title, message, recipients)
                elif channel == 'webhook' and self.config.webhook_enabled:
                    results['webhook'] = self._send_webhook(title, message, priority)
                else:
                    results[channel] = False
                    logger.warning(f"Channel {channel} not enabled or configured")

            except Exception as e:
                logger.error(f"Error sending notification via {channel}: {e}")
                results[channel] = False

        return results

    def send_email(self, recipient: str, subject: str, body: str,
                   html_body: Optional[str] = None) -> bool:
        """Send email notification to specific recipient"""
        return self._send_email(subject, body, [recipient], html_body)

    def send_business_metric_alert(self, metric_name: str, current_value: float,
                                 threshold: float, trend: str) -> bool:
        """Send specialized business metric alert"""

        # Determine priority based on threshold deviation
        deviation = abs(current_value - threshold) / threshold
        if deviation > 0.5:
            priority = 'critical'
        elif deviation > 0.2:
            priority = 'high'
        else:
            priority = 'medium'

        title = f"Business Metric Alert: {metric_name}"
        message = f"""
        Metric: {metric_name}
        Current Value: {current_value:.2f}
        Threshold: {threshold:.2f}
        Deviation: {deviation:.1%}
        Trend: {trend}

        Time: {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')}

        This alert was generated by the Automation Agent monitoring system.
        """

        return any(self.send_notification(title, message, priority).values())

    def send_inventory_alert(self, product_name: str, current_stock: int,
                           reorder_point: int, location: str) -> bool:
        """Send inventory-specific alert"""

        priority = 'critical' if current_stock == 0 else 'high'

        title = f"Inventory Alert: {product_name}"
        message = f"""
        Product: {product_name}
        Location: {location}
        Current Stock: {current_stock}
        Reorder Point: {reorder_point}

        Status: {'STOCKOUT' if current_stock == 0 else 'LOW STOCK'}

        Automated reordering may have been triggered.
        Check the inventory management system for details.
        """

        return any(self.send_notification(title, message, priority).values())

    def send_meeting_notification(self, meeting_title: str, scheduled_time: datetime,
                                attendees: List[str], status: str) -> bool:
        """Send meeting scheduling notification"""

        priority = 'medium'

        title = f"Meeting {status.title()}: {meeting_title}"
        message = f"""
        Meeting: {meeting_title}
        Status: {status.title()}
        Scheduled Time: {scheduled_time.strftime('%A, %B %d, %Y at %I:%M %p')}
        Attendees: {', '.join(attendees)}

        This meeting was {status} automatically by the AI Meeting Scheduler.
        Calendar invitations will be sent separately.
        """

        # Send to attendees specifically
        for attendee in attendees:
            self.send_email(attendee, title, message)

        return any(self.send_notification(title, message, priority).values())

    # Private methods for different notification channels

    def _send_email(self, subject: str, body: str,
                   recipients: Optional[List[str]] = None,
                   html_body: Optional[str] = None) -> bool:
        """Send email notification"""
        try:
            if not recipients:
                recipients = self.config.default_email_recipients or []

            if not recipients:
                logger.warning("No email recipients configured")
                return False

            # Create message
            msg = MIMEMultipart('alternative')
            msg['Subject'] = subject
            msg['From'] = self.config.from_email
            msg['To'] = ', '.join(recipients)

            # Add plain text part
            text_part = MIMEText(body, 'plain')
            msg.attach(text_part)

            # Add HTML part if provided
            if html_body:
                html_part = MIMEText(html_body, 'html')
                msg.attach(html_part)

            # Send email
            with smtplib.SMTP(self.config.smtp_host, self.config.smtp_port) as server:
                server.starttls()
                server.login(self.config.smtp_username, self.config.smtp_password)
                server.send_message(msg)

            logger.info(f"Email sent successfully to {len(recipients)} recipients")
            return True

        except Exception as e:
            logger.error(f"Failed to send email: {e}")
            return False

    def _send_slack(self, title: str, message: str) -> bool:
        """Send Slack notification"""
        try:
            if not self.config.slack_webhook_url:
                logger.warning("Slack webhook URL not configured")
                return False

            # Format message for Slack
            slack_message = {
                "channel": self.config.slack_channel,
                "username": "Automation Agent",
                "icon_emoji": ":robot_face:",
                "attachments": [
                    {
                        "color": "warning",
                        "title": title,
                        "text": message,
                        "footer": "Automation Agent",
                        "ts": int(datetime.utcnow().timestamp())
                    }
                ]
            }

            response = requests.post(
                self.config.slack_webhook_url,
                json=slack_message,
                timeout=10
            )

            if response.status_code == 200:
                logger.info("Slack notification sent successfully")
                return True
            else:
                logger.error(f"Slack notification failed: {response.status_code}")
                return False

        except Exception as e:
            logger.error(f"Failed to send Slack notification: {e}")
            return False

    def _send_sms(self, title: str, message: str,
                 recipients: Optional[List[str]] = None) -> bool:
        """Send SMS notification via Twilio"""
        try:
            # Import Twilio here to make it optional
            try:
                from twilio.rest import Client
            except ImportError:
                logger.error("Twilio library not installed. Install with: pip install twilio")
                return False

            if not recipients:
                recipients = self.config.default_sms_recipients or []

            if not recipients:
                logger.warning("No SMS recipients configured")
                return False

            # Initialize Twilio client
            client = Client(self.config.twilio_account_sid, self.config.twilio_auth_token)

            # Format SMS message (keep it short)
            sms_body = f"{title}\n\n{message[:140]}..."  # Truncate for SMS

            success_count = 0
            for recipient in recipients:
                try:
                    message = client.messages.create(
                        body=sms_body,
                        from_=self.config.twilio_from_number,
                        to=recipient
                    )
                    success_count += 1
                    logger.info(f"SMS sent to {recipient}: {message.sid}")
                except Exception as e:
                    logger.error(f"Failed to send SMS to {recipient}: {e}")

            return success_count > 0

        except Exception as e:
            logger.error(f"Failed to send SMS notifications: {e}")
            return False

    def _send_webhook(self, title: str, message: str, priority: str) -> bool:
        """Send webhook notification"""
        try:
            if not self.config.webhook_urls:
                logger.warning("No webhook URLs configured")
                return False

            webhook_payload = {
                "timestamp": datetime.utcnow().isoformat(),
                "title": title,
                "message": message,
                "priority": priority,
                "source": "automation_agent"
            }

            success_count = 0
            for webhook_url in self.config.webhook_urls:
                try:
                    response = requests.post(
                        webhook_url,
                        json=webhook_payload,
                        timeout=10,
                        headers={'Content-Type': 'application/json'}
                    )

                    if response.status_code in [200, 201, 202]:
                        success_count += 1
                        logger.info(f"Webhook notification sent to {webhook_url}")
                    else:
                        logger.error(f"Webhook failed {webhook_url}: {response.status_code}")

                except Exception as e:
                    logger.error(f"Failed to send webhook to {webhook_url}: {e}")

            return success_count > 0

        except Exception as e:
            logger.error(f"Failed to send webhook notifications: {e}")
            return False


class AlertManager:
    """
    Advanced alert management with rate limiting, escalation, and deduplication.
    """

    def __init__(self, notification_manager: NotificationManager):
        self.notification_manager = notification_manager
        self.alert_history = {}  # Track recent alerts
        self.escalation_rules = {}

    def send_alert(self, alert_type: str, alert_data: Dict,
                  cooldown_minutes: int = 60) -> bool:
        """
        Send alert with deduplication and rate limiting.

        Args:
            alert_type: Type of alert (inventory_low, meeting_conflict, etc.)
            alert_data: Alert-specific data
            cooldown_minutes: Minimum time between same alerts

        Returns:
            True if alert was sent, False if suppressed
        """
        alert_key = f"{alert_type}_{hash(str(sorted(alert_data.items())))}"
        current_time = datetime.utcnow()

        # Check if similar alert was sent recently
        if alert_key in self.alert_history:
            last_sent = self.alert_history[alert_key]
            if (current_time - last_sent).total_seconds() < cooldown_minutes * 60:
                logger.info(f"Alert {alert_type} suppressed due to cooldown")
                return False

        # Send the alert
        title, message, priority = self._format_alert(alert_type, alert_data)
        success = any(self.notification_manager.send_notification(
            title, message, priority
        ).values())

        if success:
            self.alert_history[alert_key] = current_time

        return success

    def _format_alert(self, alert_type: str, alert_data: Dict) -> tuple:
        """Format alert based on type"""

        if alert_type == 'inventory_critical':
            return (
                f"CRITICAL: {alert_data['product_name']} Stockout",
                f"Product {alert_data['product_name']} is out of stock at {alert_data['location']}. "
                f"Estimated lost sales: ${alert_data.get('potential_lost_sales', 0):.2f}",
                'critical'
            )

        elif alert_type == 'meeting_conflict':
            return (
                f"Meeting Conflict: {alert_data['meeting_title']}",
                f"Scheduling conflict detected for meeting '{alert_data['meeting_title']}' "
                f"with {len(alert_data.get('conflicting_attendees', []))} attendees.",
                'high'
            )

        elif alert_type == 'system_performance':
            return (
                f"Performance Alert: {alert_data['component']}",
                f"Performance degradation detected in {alert_data['component']}. "
                f"Current metric: {alert_data['current_value']}, "
                f"Threshold: {alert_data['threshold']}",
                'medium'
            )

        else:
            return (
                f"System Alert: {alert_type}",
                f"Alert data: {json.dumps(alert_data, indent=2)}",
                'medium'
            )


# Utility functions for common notification patterns

def create_inventory_notification_config(email_settings: Dict) -> Dict:
    """Create notification config optimized for inventory management"""
    return {
        'email_enabled': True,
        'slack_enabled': email_settings.get('slack_webhook_url') is not None,
        'sms_enabled': email_settings.get('twilio_account_sid') is not None,
        'webhook_enabled': email_settings.get('webhook_urls') is not None,

        'smtp_host': email_settings.get('smtp_host', 'smtp.gmail.com'),
        'smtp_port': email_settings.get('smtp_port', 587),
        'smtp_username': email_settings.get('smtp_username', ''),
        'smtp_password': email_settings.get('smtp_password', ''),
        'from_email': email_settings.get('from_email', ''),

        'default_email_recipients': email_settings.get('inventory_managers', []),
        'slack_webhook_url': email_settings.get('slack_webhook_url', ''),
        'slack_channel': '#inventory-alerts'
    }

def create_meeting_notification_config(email_settings: Dict) -> Dict:
    """Create notification config optimized for meeting scheduling"""
    return {
        'email_enabled': True,
        'slack_enabled': email_settings.get('slack_webhook_url') is not None,
        'sms_enabled': False,  # Usually not needed for meetings
        'webhook_enabled': email_settings.get('webhook_urls') is not None,

        'smtp_host': email_settings.get('smtp_host', 'smtp.gmail.com'),
        'smtp_port': email_settings.get('smtp_port', 587),
        'smtp_username': email_settings.get('smtp_username', ''),
        'smtp_password': email_settings.get('smtp_password', ''),
        'from_email': email_settings.get('from_email', ''),

        'default_email_recipients': email_settings.get('admin_users', []),
        'slack_webhook_url': email_settings.get('slack_webhook_url', ''),
        'slack_channel': '#scheduling'
    }